import math
import random
import node

game_state = [[" "," "," ", " "," "," ", " "," "," "],[" "," "," ", " "," "," ", " "," "," "],[" "," "," ", " "," "," ", " "," "," "],
              [" "," "," ", " "," "," ", " "," "," "],[" "," "," ", " "," "," ", " "," "," "],[" "," "," ", " "," "," ", " "," "," "],
              [" "," "," ", " "," "," ", " "," "," "],[" "," "," ", " "," "," ", " "," "," "],[" "," "," ", " "," "," ", " "," "," "]]

winners = ["O", "X", "D"]
win_loss = ["OOO", "XXX"]

correct_move_inputs = [str(i) for i in range(1, 10)]

possible_checks = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]]


check_lines = {0: [[0, 1, 2], [0, 3, 6], [0, 4, 8]],
                  1: [[0, 1, 2], [1, 4, 7]],
                  2: [[0, 1, 2], [2, 5, 8], [2, 4, 6]],
                  3: [[3, 4, 5], [0, 3, 6]],
                  4: [[3, 4, 5], [1, 4, 7], [0, 4, 8], [2, 4, 6]],
                  5: [[3, 4, 5], [2, 5, 8]],
                  6: [[6, 7, 8], [0, 3, 6], [2, 4, 6]],
                  7: [[6, 7, 8], [1, 4, 7]],
                  8: [[6, 7, 8], [2, 5, 8], [0, 4, 8]],}

possible_moves = [[0,1,2,3,4,5,6,7,8] for x in range(9)]
print(possible_moves)



class Game:
    def __init__(self, init_state):
        self.current_state = init_state
        self.major_grid = [" " *9]
        self.prev_move = None
        self.current_player = 0

    def updateMinorGrid(self, minor_grid, minor_grid_prev_move):
        # minor_grid = [" "*9]
        # minor_grid_self.prev_move = the move on that grid

        for line in check_lines[minor_grid_prev_move]:
            current_check = ""
            for value in line:
                current_check += minor_grid[value]
            
            if current_check in win_loss:
                return win_loss.index(current_check)
        
        if " " not in minor_grid:
            return 2
        else:
            return None


    # def updateMajorGrid(self, major_grid, major_grid_self.prev_move):
    #     return self.updateMinorGrid(major_grid[major_grid_self.prev_move[0]])

            # major_grid[major_grid_self.prev_move[0]] = winners.index(currentMinorResult)
            
        

    def updateMajorGrid(self, current_state, major_grid):
        # major_grid = [" "*9] describing state of entire large grid
        # current_state = [[" " * 9] * 9] describing all minigrids inside large grid

        currentMinorResult = self.updateMinorGrid(current_state[self.prev_move[0]])

        if currentMinorResult is not None:
            major_grid[self.prev_move[0]] = winners[currentMinorResult]
            possible_moves[self.prev_move[0]] = []
            self.checkWin(self.prev_move, major_grid)

    def checkWin(self, major_grid):
        return self.updateMinorGrid(major_grid, self.prev_move[0])

    
    def printGrid(self, current_state):
        for m in range(3):
            for i in range(3):
                row = ""
                for d in range(3):
                    d = d + 3 * m
                    for c in range(3):
                        c = c  + 3 * i
                        row += current_state[d][c]
                print(row)
            
    
    def swap(self):
        if self.current_player == 0:
            self.current_player = 1
        elif self.current_player == 1:
            self.current_player = 0
        else:
            raise TypeError("Only 1 or 0 allowed")
        
    def checkAskMoveA(self):
        if self.prev_move is None:
            return True
        elif not possible_moves[self.prev_move[1]]:
            return True
        else:
            return False
    
    def checkValidMoveA(self, moveA):
        if moveA in correct_move_inputs:
            if possible_moves[int(moveA) - 1]:
                return True
            
        return False
    
    def checkValidMoveB(self, move):
        if move[1] in correct_move_inputs:
            if int(move[1]) - 1 in possible_moves[int(move[0])]:
                return True
            
        return False
    
    # def getValidMoves(self):
    #     if self.prev_move is None:
    #         return possible_moves
    #     elif not self.current_state[self.prev_move[1]]:
    #         return possible_moves
    #     else:
    #         return possible_moves[self.prev_move[1]]
        
    def check_input(self, a):
        pass
        
    def getPlayerMove(self):

        if self.checkAskMoveA():
            a = input("Player %s's Move Grid: " % self.current_player)

            while not self.checkValidMoveA(a):
                print("Invalid Input")
                a = input("Player %s's Move Grid: " % self.current_player)

        else:
            a = self.prev_move[1]
        
        a = int(a) - 1
        b = input("Player %s's Move Value: " % self.current_player)
        
        while not self.checkValidMoveB((a, b)):
            print("Invalid Input")
            b = input("Player %s's Move Value: " % self.current_player)

        # valid = False
        # if b in correct_move_inputs:
        #     if valid_moves[int(b)]:
        #         valid = True

        # while not valid:
        #     print("Invalid Input")
        #     b = input("Player %s's Move Value: " % self.current_player)
        #     if b in correct_move_inputs:
        #         if valid_moves[int(b)]:
        #             valid = True
        
        return (a, int(b)-1)
    
    def add_move(self, move):
        self.current_state[move[0]][move[1]] = winners[self.current_player]
        
    def remove_possible_move(self, move):
        possible_moves[move[0]].remove(move[1])
    

    
    def run(self):
        while True:
            self.printGrid(self.current_state)
            a, b = self.getPlayerMove()
            move = a, b
            self.add_move(move)
            self.remove_possible_move(move)
            self.swap()
            self.prev_move = move

            

            


    

game = Game(game_state)

game.run()

    # grid = self.prev_move[0]
    # value = self.prev_move[1]
    # # check current_grid
    # for check_line in check_lines[value]:
    #     current_line = ""
    #     for check_value in check_line:
    #         current_line += game_state[grid][check_value]

    #     if current_line in win_loss:
    #         return win_loss.index(line)
    #     # returns winner (O = 0, X=1) or None
    
    # return None





# for i in range(9):

#     result = []

#     for line in possible_checks:
#         if i in line:
#             result.append(line)
#     print("%s: %s," % (i, result))



